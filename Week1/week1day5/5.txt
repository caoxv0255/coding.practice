A:
vector
原因：
理论分析：
缓存友好性： vector 的元素在内存中是连续存储的，这使得 CPU 缓存命中率极高，随机访问速度最快（O(1) 且常数因子最小）。
尾部操作： vector 在尾部插入（push_back）是均摊 O(1) 的，非常高效。
对比： deque 虽然也支持随机访问，但其分段连续的结构导致访问时需要多一次指针跳转（中控数组），性能略低于 vector。

B:
deque
原因：
理论分析：
双端高效： deque 的核心优势在于头尾插入和删除都是 O(1)。而 vector 在头部插入需要移动所有元素（O(n)），代价极高。
保留随机访问： 虽然 deque 的随机访问比 vector 稍慢，但它仍然支持 O(1) 的下标访问，满足了“访问中间元素”的需求。
结论： 这是 deque 的典型应用场景，它在保持双端高效的同时，没有完全牺牲随机访问能力。

C:
vector
原因：
理论分析：
内存布局： vector 保证其元素存储在一块连续的内存区域中。你可以通过 &vec[0] 或 vec.data() 获得指向这块连续内存的指针。
deque 的缺陷： deque 是分段连续的，其内部由多个不连续的内存块组成，无法提供一个指向所有元素的单一连续指针。因此，它不能直接用于 C API 交互。

D:
vector
原因：
理论分析：
扩容机制： vector 在扩容时（当容量不足），需要重新分配更大的连续内存，并将所有旧元素拷贝（或移动）到新内存中。如果对象很大且拷贝成本高，这会非常昂贵。
deque 的优势： deque 采用分段缓冲区机制，扩容时只需分配一个新的缓冲区并链接起来，不需要移动已有的元素。这极大地降低了动态增长时的开销。
注：如果使用 C++11 以上的移动语义或 emplace_back，vector 的这个问题会缓解，但 deque 依然在理论上更优。

代码验证在5.cpp

